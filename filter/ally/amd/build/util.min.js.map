{"version":3,"file":"util.min.js","sources":["../src/util.js"],"sourcesContent":["/**\n * This file is part of Moodle - http://moodle.org/\n *\n * Moodle is free software: you can redistribute it and/or modify\n * it under the terms of the GNU General Public License as published by\n * the Free Software Foundation, either version 3 of the License, or\n * (at your option) any later version.\n *\n * Moodle is distributed in the hope that it will be useful,\n * but WITHOUT ANY WARRANTY; without even the implied warranty of\n * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n * GNU General Public License for more details.\n *\n * You should have received a copy of the GNU General Public License\n * along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n *\n * Utility lib.\n *\n * @package\n * @author    Guy Thomas / Branden Visser\n * @copyright Copyright (c) 2017 Open LMS / 2023 Anthology Inc. and its affiliates\n * @license   http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\nimport $ from 'jquery';\n\nclass Util {\n\n    /**\n     * When evaluateFunction returns true.\n     * @author Guy Thomas\n     * @param {function} evaluateFunction\n     * @param {integer} maxIterations\n     * @returns {promise} jQuery promise\n     */\n    whenTrue(evaluateFunction, maxIterations) {\n\n        maxIterations = !maxIterations ? 10 : maxIterations;\n\n        const dfd = $.Deferred();\n        let i = 0;\n\n        // Maintains a handle to the interval timer, so it can be cleaned up when the element is removed.\n        let intervalHandle = null;\n\n        /**\n         * The function that will be used to try the evaluation repeatedly.\n         */\n        const loop = function() {\n            i++;\n            if (i > maxIterations) {\n                dfd.reject();\n                if (intervalHandle) {\n                    // Cleanup the interval.\n                    clearInterval(intervalHandle);\n                    intervalHandle = null;\n                }\n                return;\n            }\n            if (evaluateFunction()) {\n                dfd.resolve();\n                if (intervalHandle) {\n                    // Cleanup the interval.\n                    clearInterval(intervalHandle);\n                    intervalHandle = null;\n                }\n                return;\n            }\n        };\n\n        intervalHandle = setInterval(loop, 200);\n\n        return dfd.promise();\n    }\n\n    /**\n     * Listen for the offset/size of a given element to change. Whenever it changes, invoke the given function.\n     * @author Branden Visser\n     * @param  {jQuery}     $el                     The element to watch\n     * @param  {Function}   callback                The function that is invoked when the coords change\n     * @param  {Object}     callback.coords         The new set of coords\n     * @param  {Number}     callback.coords.top     The top offset of the element\n     * @param  {Number}     callback.coords.right   The right offset of the element\n     * @param  {Number}     callback.coords.bottom  The bottom offset of the element\n     * @param  {Number}     callback.coords.left    The left offset of the element\n     * @api private\n     */\n    onCoordsChange($el, callback) {\n\n        // Maintains the last known set of coords\n        let lastCoords = {};\n\n        // Maintains a handle to the interval timer, so it can be cleaned up when the element is removed\n        let intervalHandle = null;\n\n        /**\n         * The function that is continuously run to determine if there was a change in coords\n         */\n        const _loop = () => {\n            const offset = $el.offset();\n            const width = $el.width();\n            const height = $el.height();\n\n            const currCoords = {\n                'top': offset.top,\n                'right': offset.left + width,\n                'bottom': offset.top + height,\n                'left': offset.left\n            };\n\n            // Only continue if the coordinates have changed. Otherwise we do nothing\n            if (currCoords.top !== lastCoords.top || currCoords.right !== lastCoords.right ||\n                currCoords.bottom !== lastCoords.bottom || currCoords.left !== lastCoords.left) {\n                // Set the new set of coords\n                lastCoords = currCoords;\n\n                // First ensure the element is still on the DOM. If not, we're going to clean everything up here\n                if (!$.contains(document.documentElement, $el[0])) {\n                    if (intervalHandle) {\n                        clearInterval(intervalHandle);\n                        intervalHandle = null;\n                    }\n                    return;\n                }\n\n                // Finally, run the callback and exit.\n                callback(lastCoords);\n                return;\n            }\n        };\n\n        // Start the interval timer\n        intervalHandle = setInterval(_loop, 200);\n\n        // Perform an immediate initial run\n        _loop();\n    }\n\n    /**\n     * Builds an object which contains all the parameters passed in a URL.\n     * @param {string} url URL which has parameters\n     * @returns {Object}\n     */\n    getQuery(url) {\n        const query = {};\n\n        url.replace(/[?&](.+?)=([^&#]*)/g, function(_, key, value) {\n            query[key] = decodeURI(value).replace(/\\+/g, ' ');\n        });\n\n        return query;\n    }\n\n    /**\n     * Taken from underscore.js - debounce function to prevent function spamming on event triggers.\n     * Modified by GThomas to implement deferred.\n     * @param {function} func\n     * @param {int} wait\n     * @param {boolean} immediate\n     * @returns {Promise}\n     */\n    debounce(func, wait, immediate) {\n        let timeout;\n        return function() {\n            const dfd = $.Deferred();\n            const context = this,\n                args = arguments;\n            const later = function() {\n                timeout = null;\n                if (!immediate) {\n                    dfd.resolve(func.apply(context, args));\n                }\n            };\n            const callNow = immediate && !timeout;\n            clearTimeout(timeout);\n            timeout = setTimeout(later, wait);\n            if (callNow) {\n                dfd.resolve(func.apply(context, args));\n            }\n            return dfd;\n        };\n    }\n}\n\nexport default new Util();\n"],"names":["whenTrue","evaluateFunction","maxIterations","dfd","$","Deferred","i","intervalHandle","setInterval","reject","clearInterval","resolve","promise","onCoordsChange","$el","callback","lastCoords","_loop","offset","width","height","currCoords","top","left","right","bottom","contains","document","documentElement","getQuery","url","query","replace","_","key","value","decodeURI","debounce","func","wait","immediate","timeout","context","this","args","arguments","later","apply","callNow","clearTimeout","setTimeout"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;0JAuLe,UArJXA,SAASC,iBAAkBC,eAEvBA,cAAiBA,eAAgB,SAE3BC,IAAMC,gBAAEC,eACVC,EAAI,EAGJC,eAAiB,YA2BrBA,eAAiBC,aAtBJ,kBACTF,IACIA,EAAIJ,eACJC,IAAIM,cACAF,iBAEAG,cAAcH,gBACdA,eAAiB,QAIrBN,oBACAE,IAAIQ,eACAJ,iBAEAG,cAAcH,gBACdA,eAAiB,iBAMM,KAE5BJ,IAAIS,UAefC,eAAeC,IAAKC,cAGZC,WAAa,GAGbT,eAAiB,WAKfU,MAAQ,WACJC,OAASJ,IAAII,SACbC,MAAQL,IAAIK,QACZC,OAASN,IAAIM,SAEbC,WAAa,KACRH,OAAOI,UACLJ,OAAOK,KAAOJ,aACbD,OAAOI,IAAMF,YACfF,OAAOK,SAIfF,WAAWC,MAAQN,WAAWM,KAAOD,WAAWG,QAAUR,WAAWQ,OACrEH,WAAWI,SAAWT,WAAWS,QAAUJ,WAAWE,OAASP,WAAWO,YAE1EP,WAAaK,WAGRjB,gBAAEsB,SAASC,SAASC,gBAAiBd,IAAI,SAS9CC,SAASC,iBARDT,iBACAG,cAAcH,gBACdA,eAAiB,QAYjCA,eAAiBC,YAAYS,MAAO,KAGpCA,QAQJY,SAASC,WACCC,MAAQ,UAEdD,IAAIE,QAAQ,uBAAuB,SAASC,EAAGC,IAAKC,OAChDJ,MAAMG,KAAOE,UAAUD,OAAOH,QAAQ,MAAO,QAG1CD,MAWXM,SAASC,KAAMC,KAAMC,eACbC,eACG,iBACGtC,IAAMC,gBAAEC,WACRqC,QAAUC,KACZC,KAAOC,UACLC,MAAQ,WACVL,QAAU,KACLD,WACDrC,IAAIQ,QAAQ2B,KAAKS,MAAML,QAASE,QAGlCI,QAAUR,YAAcC,eAC9BQ,aAAaR,SACbA,QAAUS,WAAWJ,MAAOP,MACxBS,SACA7C,IAAIQ,QAAQ2B,KAAKS,MAAML,QAASE,OAE7BzC"}