{"version":3,"file":"checkboxmanager.min.js","sources":["../src/checkboxmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Checkbox manager amd module: Adds checkboxes to the activities for selecting and\n * generates a data structure of the activities and checkboxes.\n *\n * @module     block_massaction/checkboxmanager\n * @copyright  2022 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {exception as displayException} from 'core/notification';\nimport {cssIds, constants, usedMoodleCssClasses} from './massactionblock';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport events from 'core_course/events';\n\nlet localStateUpdating = false;\nlet sectionsChanged = false;\nlet sections = [];\nlet moduleNames = [];\n\n/* A registry of checkbox IDs, of the format:\n *  'section_number' => [{'moduleId'   : <module-ID>,\n *                       'boxId'       : <checkbox_id>}]\n */\nconst sectionBoxes = {};\n\n/**\n * The checkbox manager takes a given 'sections' data structure object and inserts a checkbox for each of the given\n * course modules in this data object into the DOM.\n * The checkbox manager returns another data object containing the ids of the added checkboxes.\n * @param {[]} sectionsRestricted the sections which are restrected for the course format\n */\nexport const initCheckboxManager = sectionsRestricted => {\n    const courseEditor = getCurrentCourseEditor();\n\n    const eventsToListen = {\n        SECTION_UPDATED: 'section:updated',\n        CHANGE_FINISHED: 'transaction:end'\n    };\n\n    courseEditor.stateManager.target.addEventListener(events.stateChanged, (event) => {\n        if (event.detail.action === eventsToListen.SECTION_UPDATED) {\n            // Listen to section updated events. We do not want to immediately react to the event, but wait for\n            // everything to finish updating.\n            sectionsChanged = true;\n        }\n        if (event.detail.action === eventsToListen.CHANGE_FINISHED) {\n            // Before every change to the state there is a transaction:start event. After the change is being commited,\n            // we receive an transaction:end event. That is the point we want to react to changes of the state.\n            rebuildLocalState(sectionsRestricted);\n        }\n    });\n    // Trigger rendering of sections dropdowns a first time.\n    sectionsChanged = true;\n    // Get initial state.\n    rebuildLocalState(sectionsRestricted);\n};\n\n/**\n * This method rebuilds the local state maintained in this module based on the course editor state.\n *\n * It will be called whenever a change to the courseeditor state is being detected.\n * @param {[]} sectionsRestricted the sections which are restrected for the course format\n */\nconst rebuildLocalState = sectionsRestricted => {\n    if (localStateUpdating) {\n        return;\n    }\n    localStateUpdating = true;\n    const courseEditor = getCurrentCourseEditor();\n\n    // First we rebuild our data structures depending on the course editor state.\n    sections = [];\n    for (const prop of Object.getOwnPropertyNames(sectionBoxes)) {\n        delete sectionBoxes[prop];\n    }\n    // The section map object is being sorted by section id. We have to sort after order in this course.\n    sections = [...courseEditor.stateManager.state.section.values()].sort((a, b) => a.number > b.number ? 1 : -1);\n    moduleNames = [...courseEditor.stateManager.state.cm.values()];\n\n    // Now we use the new information to rebuild dropdowns and re-apply checkboxes.\n    const sectionsUnfiltered = sections;\n    sections = filterVisibleSections(sections);\n    updateSelectionAndMoveToDropdowns(sections, sectionsUnfiltered, sectionsRestricted);\n    addCheckboxes();\n    localStateUpdating = false;\n};\n\n/**\n * Returns the currently selected module ids.\n *\n * @returns {[]} Array of module ids currently being selected\n */\nexport const getSelectedModIds = () => {\n    const moduleIds = [];\n    for (let sectionNumber in sectionBoxes) {\n        for (let i = 0; i < sectionBoxes[sectionNumber].length; i++) {\n            const checkbox = document.getElementById(sectionBoxes[sectionNumber][i].boxId);\n            if (checkbox.checked) {\n                moduleIds.push(sectionBoxes[sectionNumber][i].moduleId);\n            }\n        }\n    }\n    return moduleIds;\n};\n\n/**\n * Select all module checkboxes in section(s).\n *\n * @param {boolean} value the checked value to set the checkboxes to\n * @param {string} sectionNumber the section number of the section which all modules should be checked/unchecked. Use \"all\" to\n *  select/deselect modules in all sections.\n */\nexport const setSectionSelection = (value, sectionNumber) => {\n    const boxIds = [];\n\n    if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_SELECT_DESCRIPTION_VALUE) {\n        // Description placeholder has been selected, do nothing.\n        return;\n    } else if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_NUMBER_ALL_PLACEHOLDER) {\n        // See if we are toggling all sections.\n        for (const sectionId in sectionBoxes) {\n            for (let j = 0; j < sectionBoxes[sectionId].length; j++) {\n                boxIds.push(sectionBoxes[sectionId][j].boxId);\n            }\n        }\n    } else {\n        // We select all boxes of the given section.\n        sectionBoxes[sectionNumber].forEach(box => boxIds.push(box.boxId));\n    }\n    // Un/check the boxes.\n    for (let i = 0; i < boxIds.length; i++) {\n        document.getElementById(boxIds[i]).checked = value;\n    }\n    // Reset dropdown to standard placeholder so we trigger a change event when selecting a section, then deselecting\n    // everything and again select the same section.\n    document.getElementById(cssIds.SECTION_SELECT).value = constants.SECTION_SELECT_DESCRIPTION_VALUE;\n};\n\n/**\n * Add checkboxes to all sections.\n */\nconst addCheckboxes = () => {\n    sections.forEach(section => {\n        sectionBoxes[section.number] = [];\n        const moduleIds = section.cmlist;\n        if (moduleIds && moduleIds.length > 0 && moduleIds[0] !== '') {\n            const moduleNamesFiltered = moduleNames.filter(modinfo => moduleIds.includes(modinfo.id.toString()));\n            moduleNamesFiltered.forEach(modinfo => {\n                addCheckboxToModule(section.number, modinfo.id.toString(), modinfo.name);\n            });\n        }\n    });\n};\n\n/**\n * Add a checkbox to a module element\n *\n * @param {number} sectionNumber number of the section of the current course module\n * @param {number} moduleId id of the current course module\n * @param {string} moduleName name of the course module specified by moduleId\n */\nconst addCheckboxToModule = (sectionNumber, moduleId, moduleName) => {\n    const boxId = cssIds.BOX_ID_PREFIX + moduleId;\n    let moduleElement = document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleId)\n        .querySelector(usedMoodleCssClasses.ACTIVITY_ITEM);\n    // This additional class is only needed when we are using a legacy (pre moodle 4.0) course format.\n    let additionalCssClass;\n    if (!moduleElement) {\n        // Should only happen in legacy formats (pre moodle 4.0).\n        moduleElement = document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleId);\n        additionalCssClass = 'block-massaction-checkbox-legacy';\n    }\n\n    // Avoid creating duplicate checkboxes.\n    if (document.getElementById(boxId) === null) {\n        // Add the checkbox.\n        const checkBoxElement = document.createElement('input');\n        checkBoxElement.type = 'checkbox';\n        checkBoxElement.className = cssIds.CHECKBOX_CLASS;\n        if (additionalCssClass) {\n            checkBoxElement.classList.add(additionalCssClass);\n        }\n        checkBoxElement.id = boxId;\n\n        if (moduleElement !== null) {\n            const checkboxDescription = moduleName + constants.CHECKBOX_DESCRIPTION_SUFFIX;\n            checkBoxElement.ariaLabel = checkboxDescription;\n            checkBoxElement.name = checkboxDescription;\n            // Finally add the created checkbox element.\n            moduleElement.insertBefore(checkBoxElement, moduleElement.firstChild);\n        }\n    }\n\n    // Add the newly created checkbox to our data structure.\n    sectionBoxes[sectionNumber].push({\n        'moduleId': moduleId,\n        'boxId': boxId,\n    });\n};\n\n/**\n * Filter the sections data object depending on the visibility of the course modules contained in\n * the data object. This is neccessary, because some course formats only show specific section(s)\n * in editing mode.\n *\n * @param {[]} sections the sections data object\n * @returns {[]} the filtered sections object\n */\nconst filterVisibleSections = (sections) => {\n    // Filter all sections with modules which no checkboxes have been created for.\n    // This case should only occur in course formats where some sections are hidden.\n    return sections.filter(section => section.cmlist.length !== 0)\n        .filter(section => section.cmlist\n            .every(moduleid => document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleid) !== null));\n};\n\n/**\n * Update the selection, moveto and duplicateto dropdowns of the massaction block according to the\n * previously filtered sections.\n *\n * This method also has to be called whenever there is a module change event (moving around, adding file by Drag&Drop etc.).\n *\n * @param {[]} sections the sections object filtered before by {@link filterVisibleSections}\n * @param {[]} sectionsUnfiltered the same data object as 'sections', but still containing all sections\n * @param {[]} sectionsRestricted the sections which are restrected for the course format\n * no matter if containing modules or are visible in the current course format or not\n */\nconst updateSelectionAndMoveToDropdowns = (sections, sectionsUnfiltered, sectionsRestricted) => {\n    if (sectionsChanged) {\n        Templates.renderForPromise('block_massaction/section_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.SECTION_SELECT, html, js);\n                disableInvisibleAndEmptySections(sections);\n                // Re-register event listener.\n                document.getElementById(cssIds.SECTION_SELECT).addEventListener('change',\n                    (event) => setSectionSelection(true, event.target.value), false);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/moveto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.MOVETO_SELECT, html, js);\n                disableRestrictedSections(cssIds.MOVETO_SELECT, sectionsRestricted);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/duplicateto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.DUPLICATETO_SELECT, html, js);\n                disableRestrictedSections(cssIds.DUPLICATETO_SELECT, sectionsRestricted);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n    } else {\n        // If there has not been an event about a section change we do not have to rebuild the sections dropdowns.\n        // However there is a chance an section is being emptied or not empty anymore due to drag&dropping of modules.\n        // So we have to recalculate if we have to enable/disable the sections.\n        disableInvisibleAndEmptySections(sections);\n    }\n    // Reset the flag.\n    sectionsChanged = false;\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Enabled if section is visible and contains modules.\n * Disabled if section is not visible or doesn't contain any modules.\n *\n * @param {[]} sections the section data structure\n */\nconst disableInvisibleAndEmptySections = (sections) => {\n    Array.prototype.forEach.call(document.getElementById(cssIds.SECTION_SELECT).options, option => {\n        // Disable every element which doesn't have a visible section, except the placeholder ('description').\n        if (option.value !== constants.SECTION_SELECT_DESCRIPTION_VALUE\n                && !sections.some(section => parseInt(option.value) === section.number)) {\n            option.disabled = true;\n        } else {\n            option.disabled = false;\n        }\n    });\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown\n *  by sectionsRestricted param\n *\n * @param {string} elementId elementId to apply the restriction\n * @param {[]} sectionsRestricted the sections which are restrected for the course format\n */\nconst disableRestrictedSections = (elementId, sectionsRestricted) => {\n    Array.prototype.forEach.call(document.getElementById(elementId).options, option => {\n        // Disable every element which is in the sectionsRestricted list.\n        if (sectionsRestricted.includes(parseInt(option.value))) {\n            option.disabled = true;\n        } else {\n            option.disabled = false;\n        }\n    });\n};\n"],"names":["localStateUpdating","sectionsChanged","sections","moduleNames","sectionBoxes","sectionsRestricted","courseEditor","eventsToListen","stateManager","target","addEventListener","events","stateChanged","event","detail","action","rebuildLocalState","prop","Object","getOwnPropertyNames","state","section","values","sort","a","b","number","cm","sectionsUnfiltered","filterVisibleSections","updateSelectionAndMoveToDropdowns","addCheckboxes","moduleIds","sectionNumber","i","length","document","getElementById","boxId","checked","push","moduleId","setSectionSelection","value","boxIds","constants","SECTION_SELECT_DESCRIPTION_VALUE","SECTION_NUMBER_ALL_PLACEHOLDER","sectionId","j","forEach","box","cssIds","SECTION_SELECT","cmlist","filter","modinfo","includes","id","toString","addCheckboxToModule","name","moduleName","BOX_ID_PREFIX","additionalCssClass","moduleElement","usedMoodleCssClasses","MODULE_ID_PREFIX","querySelector","ACTIVITY_ITEM","checkBoxElement","createElement","type","className","CHECKBOX_CLASS","classList","add","checkboxDescription","CHECKBOX_DESCRIPTION_SUFFIX","ariaLabel","insertBefore","firstChild","every","moduleid","renderForPromise","then","_ref","html","js","replaceNode","disableInvisibleAndEmptySections","catch","ex","_ref2","MOVETO_SELECT","disableRestrictedSections","_ref3","DUPLICATETO_SELECT","Array","prototype","call","options","option","some","parseInt","disabled","elementId"],"mappings":"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"}