{"version":3,"file":"stackjsvle.min.js","sources":["../src/stackjsvle.js"],"sourcesContent":["/**\n * A javascript module to handle separation of author sourced scripts into\n * IFRAMES. All such scripts will have limited access to the actual document\n * on the VLE side and this script represents the VLE side endpoint for\n * message handling needed to give that access. When porting STACK onto VLEs\n * one needs to map this script to do the following:\n *\n *  1. Ensure that searches for target elements/inputs are limited to questions\n *     and do not return any elements outside them.\n *\n *  2. Map any identifiers needed to identify inputs by name.\n *\n *  3. Any change handling related to input value modifications through this\n *     logic gets connected to any such handling on the VLE side.\n *\n *\n * This script is intenttionally ordered so that the VLE specific bits should\n * be at the top.\n *\n *\n * This script assumes the following:\n *\n *  1. Each relevant IFRAME has an `id`-attribute that will be told to this\n *     script.\n *\n *  2. Each such IFRAME exists within the question itself, so that one can\n *     traverse up the DOM tree from that IFRAME to find the border of\n *     the question.\n *\n * @module     qtype_stack/stackjsvle\n * @copyright  2023 Aalto University\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\ndefine(\"qtype_stack/stackjsvle\", [\"core/event\"], function(CustomEvents) {\n    \"use strict\";\n    // Note the VLE specific include of logic.\n\n    /* All the IFRAMES have unique identifiers that they give in their\n     * messages. But we only work with those that have been created by\n     * our logic and are found from this map.\n     */\n    let IFRAMES = {};\n\n    /* For event handling, lists of IFRAMES listening particular inputs.\n     */\n    let INPUTS = {};\n\n    /* For event handling, lists of IFRAMES listening particular inputs\n     * and their input events. By default we only listen to changes.\n     * We report input events as changes to the other side.\n     */\n    let INPUTS_INPUT_EVENT = {};\n\n    /* A flag to disable certain things. */\n    let DISABLE_CHANGES = false;\n\n\n    /**\n     * Returns an element with a given id, if an only if that element exists\n     * inside a portion of DOM that represents a question.\n     *\n     * If not found or exists outside the restricted area then returns `null`.\n     *\n     * @param {String} id the identifier of the element we want.\n     */\n    function vle_get_element(id) {\n        /* In the case of Moodle we are happy as long as the element is inside\n           something with the `formulation`-class. */\n        let candidate = document.getElementById(id);\n        let iter = candidate;\n        while (iter && !iter.classList.contains('formulation')) {\n            iter = iter.parentElement;\n        }\n        if (iter && iter.classList.contains('formulation')) {\n            return candidate;\n        }\n\n        return null;\n    }\n\n    /**\n     * Returns an input element with a given name, if an only if that element\n     * exists inside a portion of DOM that represents a question.\n     *\n     * Note that, the input element may have a name that multiple questions\n     * use and to pick the preferred element one needs to pick the one\n     * within the same question as the IFRAME.\n     *\n     * Note that the input can also be a select. In the case of radio buttons\n     * returning one of the possible buttons is enough.\n     *\n     * If not found or exists outside the restricted area then returns `null`.\n     *\n     * @param {String} name the name of the input we want\n     * @param {String} srciframe the identifier of the iframe wanting it\n     */\n    function vle_get_input_element(name, srciframe) {\n        /* In the case of Moodle we are happy as long as the element is inside\n           something with the `formulation`-class. */\n        let initialcandidate = document.getElementById(srciframe);\n        let iter = initialcandidate;\n        while (iter && !iter.classList.contains('formulation')) {\n            iter = iter.parentElement;\n        }\n        if (iter && iter.classList.contains('formulation')) {\n            // iter now represents the borders of the question containing\n            // this IFRAME.\n            let possible = iter.querySelector('input[id$=\"_' + name + '\"]');\n            if (possible !== null) {\n                return possible;\n            }\n            // Radios have interesting ids, but the name makes sense\n            possible = iter.querySelector('input[id$=\"_' + name + '_1\"][type=radio]');\n            if (possible !== null) {\n                return possible;\n            }\n            possible = iter.querySelector('select[id$=\"_' + name + '\"]');\n            if (possible !== null) {\n                return possible;\n            }\n        }\n        // If none found within the question itself, search everywhere.\n        let possible = document.querySelector('.formulation input[id$=\"_' + name + '\"]');\n        if (possible !== null) {\n            return possible;\n        }\n        // Radios have interesting ids, but the name makes sense\n        possible = document.querySelector('.formulation input[id$=\"_' + name + '_1\"][type=radio]');\n        if (possible !== null) {\n            return possible;\n        }\n        possible = document.querySelector('.formulation select[id$=\"_' + name + '\"]');\n        return possible;\n    }\n\n    /**\n     * Triggers any VLE specific scripting related to updates of the given\n     * input element.\n     *\n     * @param {HTMLElement} inputelement the input element that has changed\n     */\n    function vle_update_input(inputelement) {\n        // Triggering a change event may be necessary.\n        const c = new Event('change');\n        inputelement.dispatchEvent(c);\n        // Also there are those that listen to input events.\n        const i = new Event('input');\n        inputelement.dispatchEvent(i);\n    }\n\n    /**\n     * Triggers any VLE specific scripting related to DOM updates.\n     *\n     * @param {HTMLElement} modifiedsubtreerootelement element under which changes may have happened.\n     */\n    function vle_update_dom(modifiedsubtreerootelement) {\n        CustomEvents.notifyFilterContentUpdated(modifiedsubtreerootelement);\n    }\n\n    /**\n     * Does HTML-string cleaning, i.e., removes any script payload. Returns\n     * a DOM version of the given input string.\n     *\n     * This is used when receiving replacement content for a div.\n     *\n     * @param {String} src a raw string to sanitise\n     */\n    function vle_html_sanitize(src) {\n        // This can be implemented with many libraries or by custom code\n        // however as this is typically a thing that a VLE might already have\n        // tools for we have it at this level so that the VLE can use its own\n        // tools that do things that the VLE developpers consider safe.\n\n        // As Moodle does not currently seem to have such a sanitizer in\n        // the core libraries, here is one implementation that shows what we\n        // are looking for.\n\n        // TODO: look into replacing this with DOMPurify or some such.\n\n        let parser = new DOMParser();\n        let doc = parser.parseFromString(src);\n\n        // First remove all <script> tags. Also <style> as we do not want\n        // to include too much style.\n        for (let el of doc.querySelectorAll('script, style')) {\n            el.remove();\n        }\n\n        // Check all elements for attributes.\n        for (let el of doc.querySelectorAll('*')) {\n            for (let {name, value} of el.attributes) {\n                if (is_evil_attribute(name, value)) {\n                    el.removeAttribute(name);\n                }\n            }\n        }\n\n        return doc.body;\n    }\n\n    /**\n     * Utility function trying to determine if a given attribute is evil\n     * when sanitizing HTML-fragments.\n     *\n     * @param {String} name the name of an attribute.\n     * @param {String} value the value of an attribute.\n     */\n    function is_evil_attribute(name, value) {\n        const lcname = name.toLowerCase();\n        if (lcname.startsWith('on')) {\n            // We do not allow event listeners to be defined.\n            return true;\n        }\n        if (lcname === 'src' || lcname.endsWith('href')) {\n            // Do not allow certain things in the urls.\n            const lcvalue = value.replace(/\\s+/g, '').toLowerCase();\n            // Ignore es-lint false positive.\n            /* eslint-disable no-script-url */\n            if (lcvalue.includes('javascript:') || lcvalue.includes('data:text')) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n\n    /*************************************************************************\n     * Above this are the bits that one would probably tune when porting.\n     *\n     * Below is the actuall message handling and it should be left alone.\n     */\n    window.addEventListener(\"message\", (e) => {\n        // NOTE! We do not check the source or origin of the message in\n        // the normal way. All actions that can bypass our filters to trigger\n        // something are largely irrelevant and all traffic will be kept\n        // \"safe\" as anyone could be listening.\n\n        // All messages we receive are strings, anything else is for someone\n        // else and will be ignored.\n        if (!(typeof e.data === 'string' || e.data instanceof String)) {\n            return;\n        }\n\n        // That string is a JSON encoded dictionary.\n        let msg = null;\n        try {\n            msg = JSON.parse(e.data);\n        } catch (e) {\n            // Only JSON objects that are parseable will work.\n            return;\n        }\n\n        // All messages we handle contain a version field with a particular\n        // value, for now we leave the possibility open for that value to have\n        // an actual version number suffix...\n        if (!(('version' in msg) && msg.version.startsWith('STACK-JS'))) {\n            return;\n        }\n\n        // All messages we handle must have a source and a type,\n        // and that source must be one of the registered ones.\n        if (!(('src' in msg) && ('type' in msg) && (msg.src in IFRAMES))) {\n            return;\n        }\n        let element = null;\n        let input = null;\n\n        let response = {\n            version: 'STACK-JS:1.0.0'\n        };\n\n        switch (msg.type) {\n        case 'register-input-listener':\n            // 1. Find the input.\n            input = vle_get_input_element(msg.name, msg.src);\n\n            if (input === null) {\n                // Requested something that is not available.\n                response.type = 'error';\n                response.msg = 'Failed to connect to input: \"' + msg.name + '\"';\n                response.tgt = msg.src;\n                IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(response), '*');\n                return;\n            }\n\n            response.type = 'initial-input';\n            response.name = msg.name;\n            response.tgt = msg.src;\n\n            // 2. What type of an input is this? Note that we do not\n            // currently support all types in sensible ways. In particular,\n            // anything with multiple values will be a problem.\n            if (input.nodeName.toLowerCase() === 'select') {\n                response.value = input.value;\n                response['input-type'] = 'select';\n            } else if (input.type === 'checkbox') {\n                response.value = input.checked;\n                response['input-type'] = 'checkbox';\n            } else {\n                response.value = input.value;\n                response['input-type'] = input.type;\n            }\n            if (input.type === 'radio') {\n                response.value = '';\n                for (let inp of document.querySelectorAll('input[type=radio][name=' + CSS.escape(input.name) + ']')) {\n                    if (inp.checked) {\n                        response.value = inp.value;\n                    }\n                }\n            }\n\n            // 3. Add listener for changes of this input.\n            if (input.id in INPUTS) {\n                if (msg.src in INPUTS[input.id]) {\n                    // DO NOT BIND TWICE!\n                    return;\n                }\n                if (input.type !== 'radio') {\n                    INPUTS[input.id].push(msg.src);\n                } else {\n                    let radgroup = document.querySelectorAll('input[type=radio][name=' + CSS.escape(input.name) + ']');\n                    for (let inp of radgroup) {\n                        INPUTS[inp.id].push(msg.src);\n                    }\n                }\n            } else {\n                if (input.type !== 'radio') {\n                    INPUTS[input.id] = [msg.src];\n                } else {\n                    let radgroup = document.querySelectorAll('input[type=radio][name=' + CSS.escape(input.name) + ']');\n                    for (let inp of radgroup) {\n                        INPUTS[inp.id] = [msg.src];\n                    }\n                }\n                if (input.type !== 'radio') {\n                    input.addEventListener('change', () => {\n                        if (DISABLE_CHANGES) {\n                            return;\n                        }\n                        let resp = {\n                            version: 'STACK-JS:1.0.0',\n                            type: 'changed-input',\n                            name: msg.name\n                        };\n                        if (input.type === 'checkbox') {\n                            resp['value'] = input.checked;\n                        } else {\n                            resp['value'] = input.value;\n                        }\n                        for (let tgt of INPUTS[input.id]) {\n                            resp['tgt'] = tgt;\n                            IFRAMES[tgt].contentWindow.postMessage(JSON.stringify(resp), '*');\n                        }\n                    });\n                } else {\n                    // Assume that if we received a radio button that is safe\n                    // then all its friends are also safe.\n                    let radgroup = document.querySelectorAll('input[type=radio][name=' + CSS.escape(input.name) + ']');\n                    radgroup.forEach((inp) => {\n                        inp.addEventListener('change', () => {\n                            if (DISABLE_CHANGES) {\n                                return;\n                            }\n                            let resp = {\n                                version: 'STACK-JS:1.0.0',\n                                type: 'changed-input',\n                                name: msg.name\n                            };\n                            if (inp.checked) {\n                                resp.value = inp.value;\n                            } else {\n                                // What about unsetting?\n                                return;\n                            }\n                            for (let tgt of INPUTS[inp.id]) {\n                                resp['tgt'] = tgt;\n                                IFRAMES[tgt].contentWindow.postMessage(JSON.stringify(resp), '*');\n                            }\n                        });\n                    });\n                }\n            }\n\n            if (('track-input' in msg) && msg['track-input'] && input.type !== 'radio') {\n                if (input.id in INPUTS_INPUT_EVENT) {\n                    if (msg.src in INPUTS_INPUT_EVENT[input.id]) {\n                        // DO NOT BIND TWICE!\n                        return;\n                    }\n                    INPUTS_INPUT_EVENT[input.id].push(msg.src);\n                } else {\n                    INPUTS_INPUT_EVENT[input.id] = [msg.src];\n\n                    input.addEventListener('input', () => {\n                        if (DISABLE_CHANGES) {\n                            return;\n                        }\n                        let resp = {\n                            version: 'STACK-JS:1.0.0',\n                            type: 'changed-input',\n                            name: msg.name\n                        };\n                        if (input.type === 'checkbox') {\n                            resp['value'] = input.checked;\n                        } else {\n                            resp['value'] = input.value;\n                        }\n                        for (let tgt of INPUTS_INPUT_EVENT[input.id]) {\n                            resp['tgt'] = tgt;\n                            IFRAMES[tgt].contentWindow.postMessage(JSON.stringify(resp), '*');\n                        }\n                    });\n                }\n            }\n\n            // 4. Let the requester know that we have bound things\n            //    and let it know the initial value.\n            if (!(msg.src in INPUTS[input.id])) {\n                IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(response), '*');\n            }\n\n            break;\n        case 'changed-input':\n            // 1. Find the input.\n            input = vle_get_input_element(msg.name, msg.src);\n\n            if (input === null) {\n                // Requested something that is not available.\n                const ret = {\n                    version: 'STACK-JS:1.0.0',\n                    type: 'error',\n                    msg: 'Failed to modify input: \"' + msg.name + '\"',\n                    tgt: msg.src\n                };\n                IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(ret), '*');\n                return;\n            }\n\n            // Disable change events.\n            DISABLE_CHANGES = true;\n\n            // TODO: Radio buttons should we check that value is possible?\n            if (input.type === 'checkbox') {\n                input.checked = msg.value;\n            } else {\n                input.value = msg.value;\n            }\n\n            // Trigger VLE side actions.\n            vle_update_input(input);\n\n            // Enable change tracking.\n            DISABLE_CHANGES = false;\n\n            // Tell all other frames, that care, about this.\n            response.type = 'changed-input';\n            response.name = msg.name;\n            response.value = msg.value;\n\n            for (let tgt of INPUTS[input.id]) {\n                if (tgt !== msg.src) {\n                    response.tgt = tgt;\n                    IFRAMES[tgt].contentWindow.postMessage(JSON.stringify(response), '*');\n                }\n            }\n\n            break;\n        case 'toggle-visibility':\n            // 1. Find the element.\n            element = vle_get_element(msg.target);\n\n            if (element === null) {\n                // Requested something that is not available.\n                const ret = {\n                    version: 'STACK-JS:1.0.0',\n                    type: 'error',\n                    msg: 'Failed to find element: \"' + msg.target + '\"',\n                    tgt: msg.src\n                };\n                IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(ret), '*');\n                return;\n            }\n\n            // 2. Toggle display setting.\n            if (msg.set === 'show') {\n                element.style.display = 'block';\n                // If we make something visible we should let the VLE know about it.\n                vle_update_dom(element);\n            } else if (msg.set === 'hide') {\n                element.style.display = 'none';\n            }\n\n            break;\n        case 'change-content':\n            // 1. Find the element.\n            element = vle_get_element(msg.target);\n\n            if (element === null) {\n                // Requested something that is not available.\n                const ret = {\n                    version: 'STACK-JS:1.0.0',\n                    type: 'error',\n                    msg: 'Failed to find element: \"' + msg.target + '\"',\n                    tgt: msg.src\n                };\n                IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(ret), '*');\n                return;\n            }\n\n            // 2. Secure content.\n            // 3. Switch the content.\n            element.replaceChildren(vle_html_sanitize(msg.content));\n            // If we tune something we should let the VLE know about it.\n            vle_update_dom(element);\n\n            break;\n        case 'resize-frame':\n            // 1. Find the frames wrapper div.\n            element = IFRAMES[msg.src].parentElement;\n\n            // 2. Set the wrapper size.\n            element.style.width = msg.width;\n            element.style.height = msg.height;\n\n            // 3. Reset the frame size.\n            IFRAMES[msg.src].style.width = '100%';\n            IFRAMES[msg.src].style.height = '100%';\n\n            // Only touching the size but still let the VLE know.\n            vle_update_dom(element);\n            break;\n        case 'ping':\n            // This is for testing the connection. The other end will\n            // send these untill it receives a reply.\n            // Part of the logic for startup.\n            response.type = 'ping';\n            response.tgt = msg.src;\n\n            IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(response), '*');\n            return;\n        case 'initial-input':\n        case 'error':\n            // These message types are for the other end.\n            break;\n\n        default:\n            // If we see something unexpected, lets let the other end know\n            // and make sure that they know our version. Could be that this\n            // end has not been upgraded.\n            response.type = 'error';\n            response.msg = 'Unknown message-type: \"' + msg.type + '\"';\n            response.tgt = msg.src;\n\n            IFRAMES[msg.src].contentWindow.postMessage(JSON.stringify(response), '*');\n        }\n\n    });\n\n\n    return {\n        /* To avoid any logic that forbids IFRAMEs in the VLE output one can\n           also create and register that IFRAME through this logic. This\n           also ensures that all relevant security settigns for that IFRAME\n           have been correctly tuned.\n\n           Here the IDs are for the secrect identifier that may be present\n           inside the content of that IFRAME and for the question that contains\n           it. One also identifies a DIV element that marks the position of\n           the IFRAME and limits the size of the IFRAME (all IFRAMEs this\n           creates will be 100% x 100%).\n\n           @param {String} iframeid the id that the IFRAME has stored inside\n                  it and uses for communication.\n           @param {String} the full HTML content of that IFRAME.\n           @param {String} targetdivid the id of the element (div) that will\n                  hold the IFRAME.\n           @param {String} title a descriptive name for the iframe.\n           @param {bool} scrolling whether we have overflow:scroll or\n                  overflow:hidden.\n         */\n        create_iframe(iframeid, content, targetdivid, title, scrolling) {\n            const frm = document.createElement('iframe');\n            frm.id = iframeid;\n            frm.style.width = '100%';\n            frm.style.height = '100%';\n            frm.style.border = 0;\n            if (scrolling === false) {\n                frm.scrolling = 'no';\n                frm.style.overflow = 'hidden';\n            } else {\n                frm.scrolling = 'yes';\n            }\n            frm.title = title;\n            // Somewhat random limitation.\n            frm.referrerpolicy = 'no-referrer';\n            // We include that allow-downloads as an example of XLS-\n            // document building in JS has been seen.\n            // UNDER NO CIRCUMSTANCES DO WE ALLOW-SAME-ORIGIN!\n            // That would defeat the whole point of this.\n            frm.sandbox = 'allow-scripts allow-downloads';\n\n            // As the SOP is intentionally broken we need to allow\n            // scripts from everywhere.\n            frm.csp = \"script-src: 'unsafe-inline' 'self' '*';\";\n\n            // The target DIV will have its children removed.\n            // This allows that div to contain some sort of loading\n            // indicator until we plug in the frame.\n            // Naturally the frame will then start to load itself.\n            document.getElementById(targetdivid).replaceChildren(frm);\n            IFRAMES[iframeid] = frm;\n\n            // Move the content over.\n            const src = new Blob([content], {type: 'text/html; charset=utf-8'});\n            frm.src = URL.createObjectURL(src);\n        }\n\n    };\n});"],"names":["define","CustomEvents","IFRAMES","INPUTS","INPUTS_INPUT_EVENT","DISABLE_CHANGES","vle_get_element","id","candidate","document","getElementById","iter","classList","contains","parentElement","vle_get_input_element","name","srciframe","possible","querySelector","vle_update_dom","modifiedsubtreerootelement","notifyFilterContentUpdated","is_evil_attribute","value","lcname","toLowerCase","startsWith","endsWith","lcvalue","replace","includes","window","addEventListener","e","data","String","msg","JSON","parse","version","src","element","input","response","type","tgt","contentWindow","postMessage","stringify","nodeName","checked","querySelectorAll","CSS","escape","inp","push","resp","forEach","ret","inputelement","c","Event","dispatchEvent","i","vle_update_input","target","set","style","display","replaceChildren","doc","DOMParser","parseFromString","remove","el","attributes","removeAttribute","body","vle_html_sanitize","content","width","height","create_iframe","iframeid","targetdivid","title","scrolling","frm","createElement","border","overflow","referrerpolicy","sandbox","csp","Blob","URL","createObjectURL"],"mappings":"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"}