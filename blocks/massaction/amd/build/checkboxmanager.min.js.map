{"version":3,"file":"checkboxmanager.min.js","sources":["../src/checkboxmanager.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Checkbox manager amd module: Adds checkboxes to the activities for selecting and\n * generates a data structure of the activities and checkboxes.\n *\n * @module     block_massaction/checkboxmanager\n * @copyright  2022 ISB Bayern\n * @author     Philipp Memmel\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {exception as displayException} from 'core/notification';\nimport {cssIds, constants, usedMoodleCssClasses} from './massactionblock';\nimport {getCurrentCourseEditor} from 'core_courseformat/courseeditor';\nimport events from 'core_course/events';\n\nlet localStateUpdating = false;\nlet sectionsChanged = false;\nlet sections = [];\nlet moduleNames = [];\n\n/* A registry of checkbox IDs, of the format:\n *  'section_number' => [{'moduleId'   : <module-ID>,\n *                       'boxId'       : <checkbox_id>}]\n */\nconst sectionBoxes = {};\n\n/**\n * The checkbox manager takes a given 'sections' data structure object and inserts a checkbox for each of the given\n * course modules in this data object into the DOM.\n * The checkbox manager returns another data object containing the ids of the added checkboxes.\n */\nexport const initCheckboxManager = () => {\n    const courseEditor = getCurrentCourseEditor();\n\n    const eventsToListen = {\n        SECTION_UPDATED: 'section:updated',\n        CHANGE_FINISHED: 'transaction:end'\n    };\n\n    courseEditor.stateManager.target.addEventListener(events.stateChanged, (event) => {\n        if (event.detail.action === eventsToListen.SECTION_UPDATED) {\n            // Listen to section updated events. We do not want to immediately react to the event, but wait for\n            // everything to finish updating.\n            sectionsChanged = true;\n        }\n        if (event.detail.action === eventsToListen.CHANGE_FINISHED) {\n            // Before every change to the state there is a transaction:start event. After the change is being commited,\n            // we receive an transaction:end event. That is the point we want to react to changes of the state.\n            rebuildLocalState();\n        }\n    });\n    // Trigger rendering of sections dropdowns a first time.\n    sectionsChanged = true;\n    // Get initial state.\n    rebuildLocalState();\n};\n\n/**\n * This method rebuilds the local state maintained in this module based on the course editor state.\n *\n * It will be called whenever a change to the courseeditor state is being detected.\n */\nconst rebuildLocalState = () => {\n    if (localStateUpdating) {\n        return;\n    }\n    localStateUpdating = true;\n    const courseEditor = getCurrentCourseEditor();\n\n    // First we rebuild our data structures depending on the course editor state.\n    sections = [];\n    for (const prop of Object.getOwnPropertyNames(sectionBoxes)) {\n        delete sectionBoxes[prop];\n    }\n    // The section map object is being sorted by section id. We have to sort after order in this course.\n    sections = [...courseEditor.stateManager.state.section.values()].sort((a, b) => a.number > b.number ? 1 : -1);\n    moduleNames = [...courseEditor.stateManager.state.cm.values()];\n\n    // Now we use the new information to rebuild dropdowns and re-apply checkboxes.\n    const sectionsUnfiltered = sections;\n    sections = filterVisibleSections(sections);\n    updateSelectionAndMoveToDropdowns(sections, sectionsUnfiltered);\n    addCheckboxesToDataStructure();\n    localStateUpdating = false;\n};\n\n/**\n * Returns the currently selected module ids.\n *\n * @returns {[]} Array of module ids currently being selected\n */\nexport const getSelectedModIds = () => {\n    const moduleIds = [];\n    for (let sectionNumber in sectionBoxes) {\n        for (let i = 0; i < sectionBoxes[sectionNumber].length; i++) {\n            const checkbox = document.getElementById(sectionBoxes[sectionNumber][i].boxId);\n            if (checkbox.checked) {\n                moduleIds.push(sectionBoxes[sectionNumber][i].moduleId);\n            }\n        }\n    }\n    return moduleIds;\n};\n\n/**\n * Select all module checkboxes in section(s).\n *\n * @param {boolean} value the checked value to set the checkboxes to\n * @param {string} sectionNumber the section number of the section which all modules should be checked/unchecked. Use \"all\" to\n *  select/deselect modules in all sections.\n */\nexport const setSectionSelection = (value, sectionNumber) => {\n    const boxIds = [];\n\n    if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_SELECT_DESCRIPTION_VALUE) {\n        // Description placeholder has been selected, do nothing.\n        return;\n    } else if (typeof sectionNumber !== 'undefined' && sectionNumber === constants.SECTION_NUMBER_ALL_PLACEHOLDER) {\n        // See if we are toggling all sections.\n        for (const sectionId in sectionBoxes) {\n            for (let j = 0; j < sectionBoxes[sectionId].length; j++) {\n                boxIds.push(sectionBoxes[sectionId][j].boxId);\n            }\n        }\n    } else {\n        // We select all boxes of the given section.\n        sectionBoxes[sectionNumber].forEach(box => boxIds.push(box.boxId));\n    }\n    // Un/check the boxes.\n    for (let i = 0; i < boxIds.length; i++) {\n        document.getElementById(boxIds[i]).checked = value;\n    }\n    // Reset dropdown to standard placeholder so we trigger a change event when selecting a section, then deselecting\n    // everything and again select the same section.\n    document.getElementById(cssIds.SECTION_SELECT).value = constants.SECTION_SELECT_DESCRIPTION_VALUE;\n};\n\n/**\n * Scan all available checkboxes and add them to the data structure.\n */\nconst addCheckboxesToDataStructure = () => {\n    sections.forEach(section => {\n        sectionBoxes[section.number] = [];\n        const moduleIds = section.cmlist;\n        if (moduleIds && moduleIds.length > 0 && moduleIds[0] !== '') {\n            const moduleNamesFiltered = moduleNames.filter(modinfo => moduleIds.includes(modinfo.id.toString()));\n            moduleNamesFiltered.forEach(modinfo => {\n                // Checkbox should already be created by moodle massactions. Just add it to our data structure.\n                const boxId = usedMoodleCssClasses.BOX_ID_PREFIX + modinfo.id.toString();\n                sectionBoxes[section.number].push({\n                    'moduleId': modinfo.id.toString(),\n                    'boxId': boxId,\n                });\n            });\n        }\n    });\n};\n\n/**\n * Filter the sections data object depending on the visibility of the course modules contained in\n * the data object. This is necessary, because some course formats only show specific section(s)\n * in editing mode.\n *\n * @param {[]} sections the sections data object\n * @returns {[]} the filtered sections object\n */\nconst filterVisibleSections = (sections) => {\n    // Filter all sections with modules which no checkboxes have been created for.\n    // This case should only occur in course formats where some sections are hidden.\n    return sections.filter(section => section.cmlist.length !== 0)\n        .filter(section => section.cmlist\n            .every(moduleid => document.getElementById(usedMoodleCssClasses.MODULE_ID_PREFIX + moduleid) !== null));\n};\n\n/**\n * Update the selection, moveto and duplicateto dropdowns of the massaction block according to the\n * previously filtered sections.\n *\n * This method also has to be called whenever there is a module change event (moving around, adding file by Drag&Drop etc.).\n *\n * @param {[]} sections the sections object filtered before by {@link filterVisibleSections}\n * @param {[]} sectionsUnfiltered the same data object as 'sections', but still containing all sections\n */\nconst updateSelectionAndMoveToDropdowns = (sections, sectionsUnfiltered) => {\n    if (sectionsChanged) {\n        Templates.renderForPromise('block_massaction/section_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.SECTION_SELECT, html, js);\n                disableInvisibleAndEmptySections(sections);\n                // Re-register event listener.\n                document.getElementById(cssIds.SECTION_SELECT).addEventListener('change',\n                    (event) => setSectionSelection(true, event.target.value), false);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/moveto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.MOVETO_SELECT, html, js);\n                disableUnavailableSections(cssIds.MOVETO_SELECT);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n\n        Templates.renderForPromise('block_massaction/duplicateto_select', {'sections': sectionsUnfiltered})\n            .then(({html, js}) => {\n                Templates.replaceNode('#' + cssIds.DUPLICATETO_SELECT, html, js);\n                disableUnavailableSections(cssIds.DUPLICATETO_SELECT);\n                return true;\n            })\n            .catch(ex => displayException(ex));\n    } else {\n        // If there has not been an event about a section change we do not have to rebuild the sections dropdowns.\n        // However, there is a chance a section is being emptied or not empty anymore due to drag&dropping of modules.\n        // So we have to recalculate if we have to enable/disable the sections.\n        disableInvisibleAndEmptySections(sections);\n    }\n    // Reset the flag.\n    sectionsChanged = false;\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Enabled if section is visible and contains modules.\n * Disabled if section is not visible or doesn't contain any modules.\n *\n * @param {[]} sections the section data structure\n */\nconst disableInvisibleAndEmptySections = (sections) => {\n    Array.prototype.forEach.call(document.getElementById(cssIds.SECTION_SELECT).options, option => {\n        // Disable every element which doesn't have a visible section, except the placeholder ('description').\n        if (option.value !== constants.SECTION_SELECT_DESCRIPTION_VALUE\n                && !sections.some(section => parseInt(option.value) === section.number)) {\n            option.disabled = true;\n        } else {\n            option.disabled = false;\n        }\n    });\n};\n\n/**\n * Sets the disabled/enabled status of sections in the section select dropdown:\n * Disabled if the section is not available due to some restrictions in block_massaction itself (provided by hooks).\n *\n * @param {string} elementId elementId to apply the restriction\n */\nconst disableUnavailableSections = (elementId) => {\n    if (document.getElementById(elementId) !== null) {\n        const sectionsAvailableInfo = document.querySelector(cssIds.SECTION_FILTER_DATA).dataset.availabletargetsections;\n        const sectionsAvailable = Array.prototype.map.call(sectionsAvailableInfo.split(','), (sectionnum) => parseInt(sectionnum));\n        Array.prototype.forEach.call(document.getElementById(elementId).options, option => {\n            // Disable every element which is not in the sectionsAvailable list.\n            if (sectionsAvailable.includes(parseInt(option.value))) {\n                option.disabled = false;\n            } else {\n                option.disabled = true;\n            }\n        });\n    }\n};\n"],"names":["localStateUpdating","sectionsChanged","sections","moduleNames","sectionBoxes","courseEditor","eventsToListen","stateManager","target","addEventListener","events","stateChanged","event","detail","action","rebuildLocalState","prop","Object","getOwnPropertyNames","state","section","values","sort","a","b","number","cm","sectionsUnfiltered","filterVisibleSections","updateSelectionAndMoveToDropdowns","addCheckboxesToDataStructure","moduleIds","sectionNumber","i","length","document","getElementById","boxId","checked","push","moduleId","setSectionSelection","value","boxIds","constants","SECTION_SELECT_DESCRIPTION_VALUE","SECTION_NUMBER_ALL_PLACEHOLDER","sectionId","j","forEach","box","cssIds","SECTION_SELECT","cmlist","filter","modinfo","includes","id","toString","usedMoodleCssClasses","BOX_ID_PREFIX","every","moduleid","MODULE_ID_PREFIX","renderForPromise","then","_ref","html","js","replaceNode","disableInvisibleAndEmptySections","catch","ex","_ref2","MOVETO_SELECT","disableUnavailableSections","_ref3","DUPLICATETO_SELECT","Array","prototype","call","options","option","some","parseInt","disabled","elementId","sectionsAvailableInfo","querySelector","SECTION_FILTER_DATA","dataset","availabletargetsections","sectionsAvailable","map","split","sectionnum"],"mappings":"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"}