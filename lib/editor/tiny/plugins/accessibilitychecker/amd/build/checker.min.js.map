{"version":3,"file":"checker.min.js","sources":["../src/checker.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/*\n * @package    tiny_accessibilitychecker\n * @copyright  2022, Stevani Andolo  <stevani@hotmail.com.au>\n * @license    http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport {get_string as getString, get_strings as getStrings} from 'core/str';\nimport {component} from './common';\nimport * as Modal from 'core/modal_factory';\nimport * as ModalEvents from 'core/modal_events';\nimport ColorBase from './colorbase';\nimport {getPlaceholderSelectors} from 'editor_tiny/options';\n\n/**\n * @typedef ProblemDetail\n * @type {object}\n * @param {string} description The description of the problem\n * @param {ProblemNode[]} problemNodes The list of affected nodes\n */\n\n/**\n * @typedef ProblemNode\n * @type {object}\n * @param {string} nodeName The node name for the affected node\n * @param {string} nodeIndex The indexd of the node\n * @param {string} text A description of the issue\n * @param {string} src The source of the image\n */\n\nexport default class {\n\n    constructor(editor) {\n        this.editor = editor;\n        this.colorBase = new ColorBase();\n        this.modal = null;\n        this.placeholderSelectors = null;\n        const placeholders = getPlaceholderSelectors(this.editor);\n        if (placeholders.length) {\n            this.placeholderSelectors = placeholders.join(', ');\n        }\n    }\n\n    destroy() {\n        delete this.editor;\n        delete this.colorBase;\n\n        this.modal.destroy();\n        delete this.modal;\n    }\n\n    async displayDialogue() {\n        this.modal = await Modal.create({\n            type: Modal.types.DEFAULT,\n            large: true,\n            title: getString('pluginname', component),\n            body: this.getDialogueContent()\n        });\n\n        // Destroy the class when hiding the modal.\n        this.modal.getRoot().on(ModalEvents.hidden, () => this.destroy());\n\n        this.modal.getRoot()[0].addEventListener('click', (event) => {\n            const faultLink = event.target.closest('[data-action=\"highlightfault\"]');\n            if (!faultLink) {\n                return;\n            }\n\n            event.preventDefault();\n\n            const nodeName = faultLink.dataset.nodeName;\n            let selectedNode = null;\n            if (nodeName) {\n                if (nodeName.includes(',') || nodeName === 'body') {\n                    selectedNode = this.editor.dom.select('body')[0];\n                } else {\n                    const nodeIndex = faultLink.dataset.nodeIndex ?? 0;\n                    selectedNode = this.editor.dom.select(nodeName)[nodeIndex];\n                }\n            }\n\n            if (selectedNode && selectedNode.nodeName.toUpperCase() !== 'BODY') {\n                this.selectAndScroll(selectedNode);\n            }\n\n            this.modal.hide();\n        });\n\n        this.modal.show();\n    }\n\n    async getAllWarningStrings() {\n        const keys = [\n            'emptytext',\n            'entiredocument',\n            'imagesmissingalt',\n            'needsmorecontrast',\n            'needsmoreheadings',\n            'tablesmissingcaption',\n            'tablesmissingheaders',\n            'tableswithmergedcells',\n        ];\n\n        const stringValues = await getStrings(keys.map((key) => ({key, component})));\n        return new Map(keys.map((key, index) => ([key, stringValues[index]])));\n    }\n\n    /**\n     * Return the dialogue content.\n     *\n     * @return {Promise<Array>} A template promise containing the rendered dialogue content.\n     */\n     async getDialogueContent() {\n        const langStrings = await this.getAllWarningStrings();\n\n        // Translate langstrings into real strings.\n        const warnings = this.getWarnings().map((warning) => {\n            if (warning.description) {\n                if (warning.description.type === 'langstring') {\n                    warning.description = langStrings.get(warning.description.value);\n                } else {\n                    warning.description = warning.description.value;\n                }\n            }\n\n            warning.nodeData = warning.nodeData.map((problemNode) => {\n                if (problemNode.text) {\n                    if (problemNode.text.type === 'langstring') {\n                        problemNode.text = langStrings.get(problemNode.text.value);\n                    } else {\n                        problemNode.text = problemNode.text.value;\n                    }\n                }\n\n                return problemNode;\n            });\n\n            return warning;\n        });\n\n        return Templates.render('tiny_accessibilitychecker/warning_content', {\n            warnings\n        });\n    }\n\n    /**\n     * Set the selection and scroll to the selected element.\n     *\n     * @param {node} node\n     */\n    selectAndScroll(node) {\n        this.editor.selection.select(node).scrollIntoView({\n            behavior: 'smooth',\n            block: 'nearest'\n        });\n    }\n\n    /**\n     * Find all problems with the content editable region.\n     *\n     * @return {ProblemDetail[]} A complete list of all warnings and problems.\n     */\n    getWarnings() {\n        const warnings = [];\n\n        // Check Images with no alt text or dodgy alt text.\n        warnings.push(this.createWarnings('imagesmissingalt', this.checkImage(), true));\n        warnings.push(this.createWarnings('needsmorecontrast', this.checkOtherElements(), false));\n\n        // Check for no headings.\n        if (this.editor.getContent({format: 'text'}).length > 1000 && this.editor.dom.select('h3,h4,h5').length < 1) {\n            warnings.push(this.createWarnings('needsmoreheadings', [this.editor], false));\n        }\n\n        // Check for tables with no captions.\n        warnings.push(this.createWarnings('tablesmissingcaption', this.checkTableCaption(), false));\n\n        // Check for tables with merged cells.\n        warnings.push(this.createWarnings('tableswithmergedcells', this.checkTableMergedCells(), false));\n\n        // Check for tables with no row/col headers.\n        warnings.push(this.createWarnings('tablesmissingheaders', this.checkTableHeaders(), false));\n\n        return warnings.filter((warning) => warning.nodeData.length > 0);\n    }\n\n    /**\n     * Generate the data that describes the issues found.\n     *\n     * @param {String} description Description of this failure.\n     * @param {HTMLElement[]} nodes An array of failing nodes.\n     * @param {boolean} isImageType Whether the warnings are related to image type checks\n     * @return {ProblemDetail[]} A set of problem details\n     */\n    createWarnings(description, nodes, isImageType) {\n        const getTextValue = (node) => {\n            if (node === this.editor) {\n                return {\n                    type: 'langstring',\n                    value: 'entiredocument',\n                };\n            }\n\n            const emptyStringValue = {\n                type: 'langstring',\n                value: 'emptytext',\n            };\n            if ('innerText' in node) {\n                const value = node.innerText.trim();\n                return value.length ? {type: 'raw', value} : emptyStringValue;\n            } else if ('textContent' in node) {\n                const value = node.textContent.trim();\n                return value.length ? {type: 'raw', value} : emptyStringValue;\n            }\n\n            return {type: 'raw', value: node.nodeName};\n        };\n\n        const getEventualNode = (node) => {\n            if (node !== this.editor) {\n                return node;\n            }\n            const childNodes = node.dom.select('body')[0].childNodes;\n            if (childNodes.length) {\n                return document.body;\n            } else {\n                return childNodes;\n            }\n        };\n\n        const warning = {\n            description: {\n                type: 'langstring',\n                value: description,\n            },\n            nodeData: [],\n        };\n\n        warning.nodeData = [...nodes].filter((node) => {\n            // If the failed node is a placeholder element. We should remove it from the list.\n            if (node !== this.editor && this.placeholderSelectors) {\n                return node.matches(this.placeholderSelectors) === false;\n            }\n\n            return node;\n        }).map((node) => {\n            const describedNode = getEventualNode(node);\n\n            // Find the index of the node within the type of node.\n            // This is used to select the correct node when the user selects it.\n            const nodeIndex = this.editor.dom.select(describedNode.nodeName).indexOf(describedNode);\n            const warning = {\n                src: null,\n                text: null,\n                nodeName: describedNode.nodeName,\n                nodeIndex,\n            };\n\n            if (isImageType) {\n                warning.src = node.getAttribute('src');\n            } else {\n                warning.text = getTextValue(node);\n            }\n\n            return warning;\n        });\n\n        return warning;\n    }\n\n    /**\n     * Check accessiblity issue only for img type.\n     *\n     * @return {Node} A complete list of all warnings and problems.\n     */\n    checkImage() {\n        const problemNodes = [];\n        this.editor.dom.select('img').forEach((img) => {\n            const alt = img.getAttribute('alt');\n            if (!alt && img.getAttribute('role') !== 'presentation') {\n                problemNodes.push(img);\n            }\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Look for any table without a caption.\n     *\n     * @return {Node} A complete list of all warnings and problems.\n     */\n    checkTableCaption() {\n        const problemNodes = [];\n        this.editor.dom.select('table').forEach((table) => {\n            const caption = table.querySelector('caption');\n            if (!caption?.textContent.trim()) {\n                problemNodes.push(table);\n            }\n        });\n\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue for not img and table only.\n     *\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkOtherElements() {\n        const problemNodes = [];\n\n        const getRatio = (lum1, lum2) => {\n            // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n            if (lum1 > lum2) {\n                return (lum1 + 0.05) / (lum2 + 0.05);\n            } else {\n                return (lum2 + 0.05) / (lum1 + 0.05);\n            }\n        };\n        this.editor.dom.select('body > *')\n            .filter((node) => node.textContent?.trim().length)\n            .forEach((node) => {\n                const foreground = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node,\n                        window.getComputedStyle(node, null).getPropertyValue('color')\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n                const background = this.colorBase.fromArray(\n                    this.getComputedBackgroundColor(\n                        node\n                    ),\n                    this.colorBase.TYPES.RGBA\n                );\n\n                const lum1 = this.getLuminanceFromCssColor(foreground);\n                const lum2 = this.getLuminanceFromCssColor(background);\n                const ratio = getRatio(lum1, lum2);\n\n                if (ratio <= 4.5) {\n                    window.console.log(`\n                        Contrast ratio is too low: ${ratio}\n                        Colour 1: ${foreground}\n                        Colour 2: ${background}\n                        Luminance 1: ${lum1}\n                        Luminance 2: ${lum2}\n                    `);\n\n                    // We only want the highest node with dodgy contrast reported.\n                    if (!problemNodes.find((existingProblemNode) => existingProblemNode.contains(node))) {\n                        problemNodes.push(node);\n                    }\n                }\n            });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with merged cells.\n     *\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableMergedCells() {\n        const problemNodes = [];\n        this.editor.dom.select('table').forEach((table) => {\n            const rowcolspan = table.querySelectorAll('[colspan], [rowspan]');\n            if (rowcolspan.length) {\n                problemNodes.push(table);\n            }\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Check accessiblity issue only for table with no headers.\n     *\n     * @return {Node} A complete list of all warnings and problems.\n     * @private\n     */\n    checkTableHeaders() {\n        const problemNodes = [];\n\n        this.editor.dom.select('table').forEach((table) => {\n            if (table.querySelector('tr').querySelector('td')) {\n                // The first row has a non-header cell, so all rows must have at least one header.\n                const missingHeader = [...table.querySelectorAll('tr')].some((row) => {\n                    const header = row.querySelector('th');\n                    if (!header) {\n                        return true;\n                    }\n\n                    if (!header.textContent.trim()) {\n                        return true;\n                    }\n\n                    return false;\n                });\n                if (missingHeader) {\n                    // At least one row is missing the header, or it is empty.\n                    problemNodes.push(table);\n                }\n            } else {\n                // Every header must have some content.\n                if ([...table.querySelectorAll('tr th')].some((header) => !header.textContent.trim())) {\n                    problemNodes.push(table);\n                }\n            }\n        });\n        return problemNodes;\n    }\n\n    /**\n     * Convert a CSS color to a luminance value.\n     *\n     * @param {String} colortext The Hex value for the colour\n     * @return {Number} The luminance value.\n     * @private\n     */\n    getLuminanceFromCssColor(colortext) {\n        if (colortext === 'transparent') {\n            colortext = '#ffffff';\n        }\n        const color = this.colorBase.toArray(this.colorBase.toRGB(colortext));\n\n        // Algorithm from \"http://www.w3.org/TR/WCAG20-GENERAL/G18.html\".\n        const part1 = (a) => {\n            a = parseInt(a, 10) / 255.0;\n            if (a <= 0.03928) {\n                a = a / 12.92;\n            } else {\n                a = Math.pow(((a + 0.055) / 1.055), 2.4);\n            }\n            return a;\n        };\n\n        const r1 = part1(color[0]);\n        const g1 = part1(color[1]);\n        const b1 = part1(color[2]);\n\n        return 0.2126 * r1 + 0.7152 * g1 + 0.0722 * b1;\n    }\n\n    /**\n     * Get the computed RGB converted to full alpha value, considering the node hierarchy.\n     *\n     * @param {Node} node\n     * @param {String} color The initial colour. If not specified, fetches the backgroundColor from the node.\n     * @return {Array} Colour in Array form (RGBA)\n     * @private\n     */\n    getComputedBackgroundColor(node, color) {\n        if (!node.parentNode) {\n            // This is the document node and has no colour.\n            // We cannot use window.getComputedStyle on the document.\n            // If we got here, then the document has no background colour. Fall back to white.\n            return this.colorBase.toArray('rgba(255, 255, 255, 1)');\n        }\n        color = color ? color : window.getComputedStyle(node, null).getPropertyValue('background-color');\n\n        if (color.toLowerCase() === 'rgba(0, 0, 0, 0)' || color.toLowerCase() === 'transparent') {\n            color = 'rgba(1, 1, 1, 0)';\n        }\n\n        // Convert the colour to its constituent parts in RGBA format, then fetch the alpha.\n        const colorParts = this.colorBase.toArray(color);\n        const alpha = colorParts[3];\n\n        if (alpha === 1) {\n            // If the alpha of the background is already 1, then the parent background colour does not change anything.\n            return colorParts;\n        }\n\n        // Fetch the computed background colour of the parent and use it to calculate the RGB of this item.\n        const parentColor = this.getComputedBackgroundColor(node.parentNode);\n        return [\n            // RGB = (alpha * R|G|B) + (1 - alpha * solid parent colour).\n            (1 - alpha) * parentColor[0] + alpha * colorParts[0],\n            (1 - alpha) * parentColor[1] + alpha * colorParts[1],\n            (1 - alpha) * parentColor[2] + alpha * colorParts[2],\n            // We always return a colour with full alpha.\n            1\n        ];\n    }\n}\n"],"names":["_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_interopRequireWildcard","obj","__esModule","default","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_interopRequireDefault","_templates","Modal","ModalEvents","_colorbase","_exports","constructor","editor","this","colorBase","ColorBase","modal","placeholderSelectors","placeholders","getPlaceholderSelectors","length","join","destroy","async","create","type","types","DEFAULT","large","title","getString","component","body","getDialogueContent","getRoot","on","hidden","addEventListener","event","faultLink","target","closest","preventDefault","nodeName","dataset","selectedNode","includes","dom","select","_faultLink$dataset$no","nodeIndex","toUpperCase","selectAndScroll","hide","show","keys","stringValues","getStrings","map","Map","index","langStrings","getAllWarningStrings","warnings","getWarnings","warning","description","value","nodeData","problemNode","text","Templates","render","node","selection","scrollIntoView","behavior","block","push","createWarnings","checkImage","checkOtherElements","getContent","format","checkTableCaption","checkTableMergedCells","checkTableHeaders","filter","nodes","isImageType","getTextValue","emptyStringValue","innerText","trim","textContent","getEventualNode","childNodes","document","matches","describedNode","indexOf","src","getAttribute","problemNodes","forEach","img","table","caption","querySelector","_node$textContent","foreground","fromArray","getComputedBackgroundColor","window","getComputedStyle","getPropertyValue","TYPES","RGBA","background","lum1","getLuminanceFromCssColor","lum2","ratio","getRatio","console","log","concat","find","existingProblemNode","contains","querySelectorAll","some","row","header","colortext","color","toArray","toRGB","part1","a","parseInt","Math","pow","parentNode","toLowerCase","colorParts","alpha","parentColor"],"mappings":"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"}