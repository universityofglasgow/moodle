{"version":3,"file":"manual_completion_toggle.min.js","sources":["../src/manual_completion_toggle.js"],"sourcesContent":["// This file is part of Moodle - http://moodle.org/\n//\n// Moodle is free software: you can redistribute it and/or modify\n// it under the terms of the GNU General Public License as published by\n// the Free Software Foundation, either version 3 of the License, or\n// (at your option) any later version.\n//\n// Moodle is distributed in the hope that it will be useful,\n// but WITHOUT ANY WARRANTY; without even the implied warranty of\n// MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the\n// GNU General Public License for more details.\n//\n// You should have received a copy of the GNU General Public License\n// along with Moodle.  If not, see <http://www.gnu.org/licenses/>.\n\n/**\n * Provides the functionality for toggling the manual completion state of a course module through\n * the manual completion button.\n *\n * @module      core_course/manual_completion_toggle\n * @copyright   2021 Jun Pataleta <jun@moodle.com>\n * @license     http://www.gnu.org/copyleft/gpl.html GNU GPL v3 or later\n */\n\nimport Templates from 'core/templates';\nimport Notification from 'core/notification';\nimport {toggleManualCompletion} from 'core_course/repository';\nimport * as CourseEvents from 'core_course/events';\n\n/**\n * Selectors in the manual completion template.\n *\n * @type {{MANUAL_TOGGLE: string}}\n */\nconst SELECTORS = {\n    MANUAL_TOGGLE: 'button[data-action=toggle-manual-completion]',\n};\n\n/**\n * Toggle type values for the data-toggletype attribute in the core_course/completion_manual template.\n *\n * @type {{TOGGLE_UNDO: string, TOGGLE_MARK_DONE: string}}\n */\nconst TOGGLE_TYPES = {\n    TOGGLE_MARK_DONE: 'manual:mark-done',\n    TOGGLE_UNDO: 'manual:undo',\n};\n\n/**\n * Whether the event listener has already been registered for this module.\n *\n * @type {boolean}\n */\nlet registered = false;\n\n/**\n * Registers the click event listener for the manual completion toggle button.\n */\nexport const init = () => {\n    if (registered) {\n        return;\n    }\n    document.addEventListener('click', (e) => {\n        const toggleButton = e.target.closest(SELECTORS.MANUAL_TOGGLE);\n        if (toggleButton) {\n            e.preventDefault();\n            toggleManualCompletionState(toggleButton).catch(Notification.exception);\n        }\n    });\n    registered = true;\n};\n\n/**\n * Toggles the manual completion state of the module for the given user.\n *\n * @param {HTMLElement} toggleButton\n * @returns {Promise<void>}\n */\nconst toggleManualCompletionState = async(toggleButton) => {\n    // Make a copy of the original content of the button.\n    const originalInnerHtml = toggleButton.innerHTML;\n\n    // Disable the button to prevent double clicks.\n    toggleButton.setAttribute('disabled', 'disabled');\n\n    // Get button data.\n    const toggleType = toggleButton.getAttribute('data-toggletype');\n    const cmid = toggleButton.getAttribute('data-cmid');\n    const activityname = toggleButton.getAttribute('data-activityname');\n    // Get the target completion state.\n    const completed = toggleType === TOGGLE_TYPES.TOGGLE_MARK_DONE;\n\n    // Replace the button contents with the loading icon.\n    const loadingHtml = await Templates.render('core/loading', {});\n    await Templates.replaceNodeContents(toggleButton, loadingHtml, '');\n\n    try {\n        // Call the webservice to update the manual completion status.\n        await toggleManualCompletion(cmid, completed);\n\n        // All good so far. Refresh the manual completion button to reflect its new state by re-rendering the template.\n        const templateContext = {\n            cmid: cmid,\n            activityname: activityname,\n            overallcomplete: completed,\n            overallincomplete: !completed,\n            istrackeduser: true, // We know that we're tracking completion for this user given the presence of this button.\n        };\n        const renderObject = await Templates.renderForPromise('core_course/completion_manual', templateContext);\n\n        // Replace the toggle button with the newly loaded template.\n        const replacedNode = await Templates.replaceNode(toggleButton, renderObject.html, renderObject.js);\n        const newToggleButton = replacedNode.pop();\n\n        // Build manualCompletionToggled custom event.\n        const withAvailability = toggleButton.getAttribute('data-withavailability');\n        const toggledEvent = new CustomEvent(CourseEvents.manualCompletionToggled, {\n            bubbles: true,\n            detail: {\n                cmid,\n                activityname,\n                completed,\n                withAvailability,\n            }\n        });\n        // Dispatch the manualCompletionToggled custom event.\n        newToggleButton.dispatchEvent(toggledEvent);\n\n    } catch (exception) {\n        // In case of an error, revert the original state and appearance of the button.\n        toggleButton.removeAttribute('disabled');\n        toggleButton.innerHTML = originalInnerHtml;\n\n        // Show the exception.\n        Notification.exception(exception);\n    }\n};\n"],"names":["_getRequireWildcardCache","nodeInterop","WeakMap","cacheBabelInterop","cacheNodeInterop","_interopRequireDefault","obj","__esModule","default","_templates","_notification","CourseEvents","cache","has","get","newObj","hasPropertyDescriptor","Object","defineProperty","getOwnPropertyDescriptor","key","prototype","hasOwnProperty","call","desc","set","_interopRequireWildcard","SELECTORS","TOGGLE_TYPES","registered","_exports","init","document","addEventListener","e","toggleButton","target","closest","preventDefault","toggleManualCompletionState","catch","Notification","exception","async","originalInnerHtml","innerHTML","setAttribute","toggleType","getAttribute","cmid","activityname","completed","loadingHtml","Templates","render","replaceNodeContents","toggleManualCompletion","templateContext","overallcomplete","overallincomplete","istrackeduser","renderObject","renderForPromise","newToggleButton","replaceNode","html","js","pop","withAvailability","toggledEvent","CustomEvent","manualCompletionToggled","bubbles","detail","dispatchEvent","removeAttribute"],"mappings":"mNA2BmD,SAAAA,yBAAAC,aAAA,GAAA,mBAAAC,QAAA,OAAA,KAAA,IAAAC,kBAAAD,IAAAA,QAAAE,iBAAAF,IAAAA,eAAAF,yBAAA,SAAAC,aAAAA,OAAAA,YAAAG,iBAAAD,oBAAAF,YAAA,CAAA,SAAAI,uBAAAC,KAAAA,OAAAA,KAAAA,IAAAC,WAAAD,IAAAE,CAAAA,QAAAF,IAAA;;;;;;;;kFAHnDG,WAAAJ,uBAAAI,YACAC,cAAAL,uBAAAK,eAEAC,aAAmD,SAAAL,IAAAL,aAAAA,IAAAA,aAAAK,KAAAA,IAAAC,WAAAD,OAAAA,IAAAA,GAAAA,OAAAA,KAAAA,iBAAAA,KAAAE,mBAAAF,IAAAE,MAAAA,CAAAA,QAAAF,KAAAM,IAAAA,MAAAZ,yBAAAC,aAAA,GAAAW,OAAAA,MAAAC,IAAAP,KAAA,OAAAM,MAAAE,IAAAR,KAAA,IAAAS,OAAAC,GAAAA,sBAAAC,OAAAC,gBAAAD,OAAAE,yBAAAC,IAAAA,IAAAA,OAAAd,IAAAc,eAAAA,KAAAH,OAAAI,UAAAC,eAAAC,KAAAjB,IAAAc,KAAA,CAAA,IAAAI,KAAAR,sBAAAC,OAAAE,yBAAAb,IAAAc,KAAAI,KAAAA,OAAAA,KAAAV,KAAAU,KAAAC,KAAAR,OAAAC,eAAAH,OAAAK,IAAAI,MAAAT,OAAAK,KAAAd,IAAAc,IAAAL,CAAAA,OAAAP,QAAAF,IAAAM,OAAAA,MAAAa,IAAAnB,IAAAS,eAAAA,MAAA,CAAnDW,CAAAf,cAOA,MAAMgB,wBACa,+CAQbC,8BACgB,mBAStB,IAAIC,YAAa,EAiBfC,SAAAC,KAZkBA,KACZF,aAGJG,SAASC,iBAAiB,SAAUC,IAChC,MAAMC,aAAeD,EAAEE,OAAOC,QAAQV,yBAClCQ,eACAD,EAAEI,iBACFC,4BAA4BJ,cAAcK,MAAMC,cAAAA,QAAaC,WACjE,IAEJb,YAAa,EAAI,EASrB,MAAMU,4BAA8BI,qBAEhC,MAAMC,kBAAoBT,aAAaU,UAGvCV,aAAaW,aAAa,WAAY,YAGtC,MAAMC,WAAaZ,aAAaa,aAAa,mBACvCC,KAAOd,aAAaa,aAAa,aACjCE,aAAef,aAAaa,aAAa,qBAEzCG,UAAYJ,aAAenB,8BAG3BwB,kBAAoBC,WAAS7C,QAAC8C,OAAO,eAAgB,CAAA,SACrDD,WAAAA,QAAUE,oBAAoBpB,aAAciB,YAAa,IAE/D,UAEU,EAAAI,YAAsBA,wBAACP,KAAME,WAGnC,MAAMM,gBAAkB,CACpBR,KAAMA,KACNC,aAAcA,aACdQ,gBAAiBP,UACjBQ,mBAAoBR,UACpBS,eAAe,GAEbC,mBAAqBR,WAAS7C,QAACsD,iBAAiB,gCAAiCL,iBAIjFM,uBADqBV,WAAS7C,QAACwD,YAAY7B,aAAc0B,aAAaI,KAAMJ,aAAaK,KAC1DC,MAG/BC,iBAAmBjC,aAAaa,aAAa,yBAC7CqB,aAAe,IAAIC,YAAY3D,aAAa4D,wBAAyB,CACvEC,SAAS,EACTC,OAAQ,CACJxB,UACAC,0BACAC,oBACAiB,qCAIRL,gBAAgBW,cAAcL,aAEjC,CAAC,MAAO3B,WAELP,aAAawC,gBAAgB,YAC7BxC,aAAaU,UAAYD,kBAGzBH,cAAAA,QAAaC,UAAUA,UAC3B,EACF"}