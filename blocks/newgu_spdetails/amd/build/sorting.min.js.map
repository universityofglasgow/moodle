{"version":3,"file":"sorting.min.js","sources":["../src/sorting.js"],"sourcesContent":["/**\n * Function to sort a table by column name and in which direction to sort items.\n * Inspiration provided by https://www.w3schools.com/howto/howto_js_sort_table.asp\n *\n * @param {int} n - the column number to sort the rows by\n * @param {string} sortName\n * @param {string} tableName\n */\nfunction sortTable(n, sortName, tableName) {\n    let table, rows, switching, i, x, y, shouldSwitch, dir, switchcount = 0;\n    table = document.getElementById(tableName);\n    switching = true;\n    // Begin by assuming the column is of type string\n    let compareFunction = compareString;\n    // We're now including a 'raw' value for dates and weights to be sorted by.\n    if (sortName.includes('date') == true || sortName.includes('weight') == true) {\n        compareFunction = compareNumber;\n    }\n    //Set the sorting direction to ascending:\n    dir = \"asc\";\n    // Moving this here as not sure repeatedly calling this inside the loop is efficient.\n    rows = table.rows;\n    /*Make a loop that will continue until\n    no switching has been done:*/\n    while (switching) {\n        //start by saying: no switching is done:\n        switching = false;\n        /*Loop through all table rows (except the\n        first, which contains table headers):*/\n        for (i = 1; i < (rows.length - 1); i++) {\n            //start by saying there should be no switching:\n            shouldSwitch = false;\n            /*Get the two elements you want to compare,\n            one from current row and one from the next:*/\n            x = rows[i].getElementsByTagName(\"TD\")[n];\n            y = rows[i + 1].getElementsByTagName(\"TD\")[n];\n            /*check if the two rows should switch place,\n            based on the direction, asc or desc:*/\n            if (dir == \"asc\") {\n                if (compareFunction(x, y, 'asc') == true) {\n                    //if so, mark as a switch and break the loop:\n                    shouldSwitch= true;\n                    break;\n                }\n            } else if (dir == \"desc\") {\n                if (compareFunction(x, y, 'desc') == true) {\n                    //if so, mark as a switch and break the loop:\n                    shouldSwitch= true;\n                    break;\n                }\n            }\n        }\n        if (shouldSwitch) {\n            /*If a switch has been marked, make the switch\n            and mark that a switch has been done:*/\n            rows[i].parentNode.insertBefore(rows[i + 1], rows[i]);\n            switching = true;\n            //Each time a switch is done, increase this count by 1:\n            switchcount ++;\n        } else {\n            /*If no switching has been done AND the direction is \"asc\",\n            set the direction to \"desc\" and run the while loop again.*/\n            if (switchcount == 0 && dir == \"asc\") {\n                dir = \"desc\";\n                switching = true;\n            }\n        }\n    }\n    sortingStatus(sortName, dir);\n}\n\n/**\n * Function to compare two strings. This was previously using innerHTML but proved too slow.\n * The sort order is passed in also.\n *\n * @param {string} x\n * @param {string} y\n * @param {string} direction\n * @returns\n */\nlet compareString = function (x, y, direction) {\n    if (direction == 'asc') {\n        if (x.innerText.toLowerCase() > y.innerText.toLowerCase()) {\n            return true;\n        }\n        return false;\n    } else if (direction == 'desc') {\n        if (x.innerText.toLowerCase() < y.innerText.toLowerCase()) {\n            return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Function to compare two numbers. This was previously just dates but now extended\n * to include weight values.\n * The sort order (direction) is used to determine in which direction we are comparing.\n *\n * @param {string} x\n * @param {string} y\n * @param {string} direction\n * @returns\n */\nlet compareNumber = function (x, y, direction) {\n    let attXName = x.getAttributeNames().filter((attName) => { return attName.includes('data');});\n    let attYName = y.getAttributeNames().filter((attName) => { return attName.includes('data');});\n    if (direction == 'asc') {\n        if (Number(x.getAttribute(attXName[0])) > Number(y.getAttribute(attYName[0]))) {\n            return true;\n        }\n        return false;\n    } else if (direction == 'desc') {\n        if (Number(x.getAttribute(attXName[0])) < Number(y.getAttribute(attYName[0]))) {\n            return true;\n        }\n        return false;\n    }\n};\n\n/**\n * Function to make UI changes to show which direction things are being sorted in.\n *\n * @param {string} sortby\n * @param {string} sortorder\n */\nfunction sortingStatus(sortby, sortorder) {\n    let sortElement = document.querySelector('#sortby_' + sortby);\n    let excludeElement = '';\n    if (sortElement) {\n        excludeElement = sortElement;\n        if (sortorder == 'asc') {\n            sortElement.classList.add('th-sort-desc');\n            sortElement.classList.remove('th-sort-asc');\n            sortElement.setAttribute('data-value', 'desc');\n        } else {\n            sortElement.classList.add('th-sort-asc');\n            sortElement.classList.remove('th-sort-desc');\n            sortElement.setAttribute('data-value', 'asc');\n        }\n    }\n\n    // Find everything that is not the thing we've just clicked and reset its position.\n    if (excludeElement != '') {\n        let elId = excludeElement.id;\n        let els = document.querySelectorAll(\".th-sortable:not(#\" + elId + \")\");\n        els.forEach((el) => {\n            let classes = el.className;\n            let tmp = classes.match(new RegExp(/th-sort-.+/, 'g'));\n            el.classList.remove(tmp);\n            el.removeAttribute('data-value');\n        });\n    }\n}\n\nexport default sortTable;"],"names":["compareString","x","y","direction","innerText","toLowerCase","compareNumber","attXName","getAttributeNames","filter","attName","includes","attYName","Number","getAttribute","n","sortName","tableName","table","rows","switching","i","shouldSwitch","dir","switchcount","document","getElementById","compareFunction","length","getElementsByTagName","parentNode","insertBefore","sortby","sortorder","sortElement","querySelector","excludeElement","classList","add","remove","setAttribute","elId","id","querySelectorAll","forEach","el","tmp","className","match","RegExp","removeAttribute","sortingStatus"],"mappings":"2JAgFIA,cAAgB,SAAUC,EAAGC,EAAGC,iBACf,OAAbA,UACIF,EAAEG,UAAUC,cAAgBH,EAAEE,UAAUC,cAIxB,QAAbF,UACHF,EAAEG,UAAUC,cAAgBH,EAAEE,UAAUC,mBADzC,GAkBPC,cAAgB,SAAUL,EAAGC,EAAGC,eAC5BI,SAAWN,EAAEO,oBAAoBC,QAAQC,SAAqBA,QAAQC,SAAS,UAC/EC,SAAWV,EAAEM,oBAAoBC,QAAQC,SAAqBA,QAAQC,SAAS,gBAClE,OAAbR,UACIU,OAAOZ,EAAEa,aAAaP,SAAS,KAAOM,OAAOX,EAAEY,aAAaF,SAAS,KAIrD,QAAbT,UACHU,OAAOZ,EAAEa,aAAaP,SAAS,KAAOM,OAAOX,EAAEY,aAAaF,SAAS,UADtE,yBAxGQG,EAAGC,SAAUC,eACxBC,MAAOC,KAAMC,UAAWC,EAAGpB,EAAGC,EAAGoB,aAAcC,IAAKC,YAAc,EACtEN,MAAQO,SAASC,eAAeT,WAChCG,WAAY,MAERO,gBAAkB3B,kBAEW,GAA7BgB,SAASL,SAAS,SAAkD,GAA/BK,SAASL,SAAS,YACvDgB,gBAAkBrB,eAGtBiB,IAAM,MAENJ,KAAOD,MAAMC,KAGNC,WAAW,KAEdA,WAAY,EAGPC,EAAI,EAAGA,EAAKF,KAAKS,OAAS,EAAIP,OAE/BC,cAAe,EAGfrB,EAAIkB,KAAKE,GAAGQ,qBAAqB,MAAMd,GACvCb,EAAIiB,KAAKE,EAAI,GAAGQ,qBAAqB,MAAMd,GAGhC,OAAPQ,QACoC,GAAhCI,gBAAgB1B,EAAGC,EAAG,OAAgB,CAEtCoB,cAAc,cAGf,GAAW,QAAPC,KAC8B,GAAjCI,gBAAgB1B,EAAGC,EAAG,QAAiB,CAEvCoB,cAAc,QAKtBA,cAGAH,KAAKE,GAAGS,WAAWC,aAAaZ,KAAKE,EAAI,GAAIF,KAAKE,IAClDD,WAAY,EAEZI,eAImB,GAAfA,aAA2B,OAAPD,MACpBA,IAAM,OACNH,WAAY,aA8DLY,OAAQC,eACvBC,YAAcT,SAASU,cAAc,WAAaH,QAClDI,eAAiB,GACjBF,cACAE,eAAiBF,YACA,OAAbD,WACAC,YAAYG,UAAUC,IAAI,gBAC1BJ,YAAYG,UAAUE,OAAO,eAC7BL,YAAYM,aAAa,aAAc,UAEvCN,YAAYG,UAAUC,IAAI,eAC1BJ,YAAYG,UAAUE,OAAO,gBAC7BL,YAAYM,aAAa,aAAc,YAKzB,IAAlBJ,eAAsB,KAClBK,KAAOL,eAAeM,GAChBjB,SAASkB,iBAAiB,qBAAuBF,KAAO,KAC9DG,SAASC,SAELC,IADUD,GAAGE,UACCC,MAAM,IAAIC,OAAO,aAAc,MACjDJ,GAAGR,UAAUE,OAAOO,KACpBD,GAAGK,gBAAgB,kBAlF3BC,CAAcnC,SAAUO"}